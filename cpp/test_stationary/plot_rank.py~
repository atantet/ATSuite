import os
import numpy as np
from scipy import sparse
import atgraph, atgraph_sparse, atplot, atmath, atcom
import matplotlib.pyplot as plt
from matplotlib import cm, colors

fig_format = 'png'

varname = 'stream'

# Folder names
HOME = os.environ['HOME']
case_dir = HOME + '/PhD/dev/bve_t21/'
period = 'daily'
src_dir = case_dir + ('results_%s/' % period) 
src_postfix = ''

read_map = True
read_graph = False

# Dimensions
id_pc = [0, 1]
#id_pc = [0, 2]
#id_pc = [1, 2]
res_dir = 'pc' + "".join(['%d' % id_pc[k] for k in range(len(id_pc))]) + '/'

# Read data
print('Reading principal components...')
#pc = np.loadtxt(src_dir + 'pc_stream' + src_postfix + '.txt')
(nt_tot, neof) = pc.shape

# Number of states
nt = nt_tot

max_dt = 15
rng_dt = np.arange(1, max_dt + 1)
ndt = rng_dt.shape[0]

# Define low-dimensional phase space
state = pc[:nt, id_pc]

# Create directories
graph_dir = res_dir + 'graph/'
os.system('mkdir %s %s/grid %s/graph %s/degree  %s/density %s/com %s/entropy 2> /dev/null' % (res_dir, res_dir, res_dir, res_dir, res_dir, res_dir, res_dir))

# Define pdf domain
nx = 53
xbound = np.linspace(-0.015, 0.01, nx+1)
#nx = 42
#xbound = np.linspace(-0.01, 0.01, ny+1)
#nx = 35
#xbound = np.linspace(-0.015, 0.01, nx+1)

ny = 42
ybound = np.linspace(-0.01, 0.01, ny+1)
#ny = 28
#ybound = np.linspace(-0.01, 0.01, ny+1)
N = nx * ny
x = (xbound[1:] + xbound[:-1]) / 2
dx = (xbound[1:] - xbound[:-1]) / 2
y = (ybound[1:] + ybound[:-1]) / 2
dy = (ybound[1:] - ybound[:-1]) / 2
(X, Y) = np.meshgrid(x, y)
(DX, DY) = np.meshgrid(dx, dy)
(XL, YL) = (X.flatten(), Y.flatten())
(DXL, DYL) = (DX.flatten(), DY.flatten())
(XLmDXL, YLmDYL, XLpDXL, YLpDYL) = (XL - DXL, YL - DYL, XL + DXL, YL + DYL)
np.savetxt(res_dir + 'grid/x_%d.txt' % nx, x)
np.savetxt(res_dir + 'grid/y_%d.txt' % ny, y)

# Infomap configuration
ptel = ' -p 0.15 '
attempts = 1
options = ' -k -d -2 -v ' + ptel
out_infomap = ' --tree '
com_tau = 0.05
level = 0
ncom_sel_ask = 6

# Plot configuration 
src_cmap = cm.hot_r
src_cmap.set_bad('k', 0.5)
src_cmap_com = cm.gist_stern


### FIND TIME LINE TO PHASE SPACE MAP ###

if not read_graph:
    map_postfix = '_nt%d_N%d' % (nt, N)
    map_path = graph_dir + 'time2phase_map' + map_postfix
    if not read_map:
        print 'Getting states time to space map...'
        map_lil = sparse.lil_matrix((N, nt), dtype=bool)
        for t in range(nt):
            id_inbox = atmath.find_first((state[t, 0] >= XLmDXL) \
                                         & (state[t, 0] <= XLpDXL) \
                                         & (state[t, 1] >= YLmDYL) \
                                         & (state[t, 1] <= YLpDYL), True)
            if id_inbox is not None:
                map_lil[id_inbox, t] = True
        map_csr = map_lil.tocsr()
        
        # Write map
        print 'Writting CSR map to %s...' % map_path
        atgraph_sparse.write_csr(map_path, map_csr, fmt='%d')
    else:
        # Read map
        print 'Reading CSR map to %s...' % map_path
        map_csr = atgraph_sparse.read_csr(map_path, dtype=bool)


### STABILITY ANALYSIS ###

rho_phase = np.zeros((ndt,))
code_phase  = np.zeros((ndt,))
ncom_filt = np.zeros((ndt,), dtype=int)
ncom = np.zeros((ndt,), dtype=int)
entropy_rate = np.zeros((ndt,))
entropy_stationary = np.zeros((ndt,))
# Reduced entropies
intra_entropy = np.zeros((ndt,))
reduced_entropy_rate = np.zeros((ndt,))
reduced_entropy_stationary = np.zeros((ndt,))
reduced_code = np.zeros((ndt,))
reduced_code2 = np.zeros((ndt,))
reduced_compression_gap = np.zeros((ndt,))
for idt in range(ndt):
    dt = rng_dt[idt]
    print '\n\n================================================'
    print '    STARTING STABILITY ANALYSIS FOR TIME-STEP %d:' % dt
    print '================================================\n'
    # Define paths
    postfix = '_nt%d_N%d_dt%02d' % (nt, N, dt)
    graph_phase_file = 'graph_phase' + postfix

    # Define transfer operator
    adj_csr = sparse.eye(nt, nt, k=dt, dtype=bool, format='csr')

    if not read_graph:
        # Map graph
        print 'Mapping graph...'
        adj_phase_csr = map_csr * adj_csr * map_csr.T

        # Get stochastic matrix
        adj_phase_csr = atgraph_sparse.stochastic_matrix(adj_phase_csr)

        # Find disconnected
        connected = np.squeeze(np.array(adj_phase_csr.sum(1).astype(bool)))
        id_connected = np.nonzero(connected)[0]
        adj_connected_csr = adj_phase_csr[id_connected][:, id_connected]

        # Convert to COO matrix
        print 'Converting to COO...'
        adj_connected_coo = adj_connected_csr.tocoo()

        # Write pajek graph
        print 'Writing Pajek graph map and connected...'
        atgraph_sparse.coo2pajek(adj_connected_coo,
                                 graph_dir + graph_phase_file + '.net')
        np.savetxt(graph_dir + 'connected' + postfix + '.txt',
                   connected, '%d')

    else:
        print 'Reading %s...' % (graph_dir + graph_phase_file + '.net',)
        adj_connected_coo = atgraph_sparse.pajek2coo(graph_dir + graph_phase_file + '.net')
        connected = np.loadtxt(graph_dir + 'connected' + postfix + '.txt',
                               dtype=bool)
        id_connected = np.nonzero(connected)[0]

        # Convert to CSR matrix and get transpose
        print 'Convert to CSR matrix...'
        adj_connected_csr = adj_connected_coo.tocsr()

        # Get total CSR matrix
        adj_phase_lil = sparse.lil_matrix((N, N),
                                          dtype=adj_connected_csr.dtype)
        adj_phase_lil[id_connected][:, id_connected] = adj_connected_csr
        adj_phase_csr = adj_phase_lil.tocsr()

    # Number of valid points
    nc = np.sum(connected)


### ANALYSIS ###

    # Get density
    rho_phase[idt] = adj_connected_csr.nnz * 1. / nc**2
    print '\nEdge density = %6.4f\n' % rho_phase[idt]

    # Get strength
    in_strength_phase = np.array(atgraph_sparse.strength(adj_phase_csr, inward=True).reshape(ny, nx))
    np.savetxt(res_dir + 'degree/in_strength_phase' + postfix + '.txt',
               in_strength_phase)
    
    # # Plot strength map
    # fig = plt.figure()
    # plt.pcolormesh(X, Y, in_strength_phase, 40, cmap=src_cmap)
    # plt.colorbar()
    # plt.title('%d-time-step inward strength' % dt)
    # fig.savefig(res_dir + 'degree/in_strength_phase' + postfix + '.' + fig_format, dpi=300, format=fig_format, bbox_inches='tight')


    ### COMMUNITY DETECTION ###

    os.system('Infomap ' + options + ' -N ' + str(attempts) + out_infomap + graph_dir + graph_phase_file + '.net ' + res_dir + 'com/')

    print 'Reading infomap tree...'
    tree_file = res_dir + 'com/' + graph_phase_file + '.tree'
    (multi_member, rank_phase, code_phase[idt]) = atgraph.read_tree(tree_file)
    nlev = multi_member.shape[1]
    print 'Number of levels: ', nlev
    
    # Save communities
    np.savetxt(res_dir + 'com/com_multi_phase' + postfix + '.txt',
               multi_member, '%d')
    np.savetxt(res_dir + 'com/rank_phase' + postfix + '.txt',
               rank_phase, '%e')

    # Filter communities
    member = multi_member[:, level]
    coms = np.unique(member)
    ncom[idt] = coms.shape[0]
    mem_filt = atgraph.community_filter(member, com_tau)
    coms_filt = np.unique(mem_filt)
    ncom_filt[idt] = coms_filt.shape[0]

    # Get entropy and compression gap
    entropy_stationary[idt] = atmath.entropy(rank_phase[rank_phase != 0])
    adj_entropy_csr = adj_connected_csr.copy()
    adj_entropy_csr.data = adj_entropy_csr.data * np.log2(adj_entropy_csr.data)
    entropy_rate[idt] = -np.sum(np.matrix(rank_phase) * adj_entropy_csr.sum(1))

    # Get reduced transfer operator
    com2com_trans = atgraph_sparse.com2comTrans(adj_connected_csr,
                                                member)
    # Get reduced stationary entropy
    rank_com = atgraph.community_rank(member, rank_phase)
    reduced_entropy_stationary[idt] = atmath.entropy(rank_com[rank_com > 0])
    intra_entropy[idt] = 0.
    for k in range(len(rank_com)):
        intra_entropy[idt] += -np.sum(rank_phase[(rank_phase > 0) & (member == coms[k])] * np.log2(rank_phase[(rank_phase > 0) & (member == coms[k])] / rank_com[k]))
    # Get reduced entropy rate
    reduced_entropy_csr = com2com_trans.copy()
    reduced_entropy_csr.data = reduced_entropy_csr.data * np.log2(reduced_entropy_csr.data)
    reduced_entropy_rate[idt] = -np.sum(np.matrix(rank_com[rank_com > 0]) * reduced_entropy_csr.sum(1)[rank_com > 0])
    # Reduced code
    reduced_code[idt] = intra_entropy[idt] + reduced_entropy_rate[idt]
    (reduced_code2[idt], crap, crap, crap) = atcom.twolevelCodelengthFromTrans(adj_connected_csr, member)

    # Get gap
    reduced_compression_gap[idt] = (entropy_stationary[idt] - reduced_entropy_rate[idt]) / reduced_entropy_rate[idt]
    if reduced_compression_gap[idt] > 20:
        reduced_compression_gap[idt] = 20


    print 'Entropy rate: ', entropy_rate[idt]
    print 'Code length: ', code_phase[idt]
    print 'Entropy of stationary distribution: ', entropy_stationary[idt]

    print '\nIntra entropy: ', intra_entropy[idt]
    print 'Reduced entropy stationary: ', reduced_entropy_stationary[idt]
    print 'Reduced entropy rate: ', reduced_entropy_rate[idt]
    print 'Reduced code: ', reduced_code[idt]
    print 'Reduced compression gap: ', reduced_compression_gap[idt]
    
    # Plot stationary distribution (PageRank)
    fig = plt.figure()
    rank_all = np.ma.masked_all((N,), dtype=rank_phase.dtype)
    rank_all[connected] = rank_phase
    plt.pcolormesh(X, Y, rank_all.reshape(ny, nx),
                 cmap=src_cmap)
    cbar = plt.colorbar()
    plt.title('%d-time-step stationary distribution' % dt)
    fig.savefig(res_dir + 'com/rank_phase' + postfix + '.' + fig_format,
                dpi=300, format=fig_format, bbox_inches='tight')

    ncom_sel = ncom_sel_ask
    if ncom_filt[idt] < ncom_sel_ask:
        ncom_sel = ncom_filt[idt]
    if 0 not in coms_filt:
        has_unassigned=False
        sel_com = np.arange(0, ncom_sel)
    else:
        has_unassigned=True
        sel_com = np.arange(1, ncom_sel)

    if np.any(coms_filt > 0):
        print 'Level %d number of filtered communities: %d' % (level, ncom_filt[idt])

        fig = plt.figure()
        if ncom_filt[idt] > 1:
            cmap_com = atplot.get_cmap_com(ncom_filt[idt], src_cmap=src_cmap_com, has_unassigned=has_unassigned)
        else:
            cmap_com = src_cmap_com
        cmap_com.set_bad('k', 0.5)
        
        mem_filt_all = np.ma.masked_all((N,), dtype=mem_filt.dtype)
        mem_filt_all[connected] = mem_filt
        pcol = plt.pcolormesh(X, Y, mem_filt_all.reshape(ny, nx),
                              cmap=cmap_com, linewidth=0)
        if ncom_filt[idt] > 1:
            atplot.cbar_com(plt, pcol, coms_filt, rank_com=rank_com,
                            has_unassigned=has_unassigned)
        plt.title('%d-time-step ommunity map at level %d' % (dt, level))
        fig.savefig(res_dir + 'com/com_phase_lev%d%s.%s' % (level, postfix, fig_format), dpi=300, format=fig_format, bbox_inches='tight')

        # Get node to community flow
        # node2com_flow = atgraph_sparse.node2com_flow_from_flow(adj_connected_csr, mem_filt, direction = 'to')
        
        # # Plot node to community probabilities
        # for k in range(len(sel_com)):
        #     fig = plt.figure()
        #     node2com_flow_all = np.ma.masked_all((N,),
        #                                          dtype=node2com_flow.dtype)
        #     node2com_flow_all[connected] = node2com_flow[:, sel_com[k]]
        #     plt.pcolormesh(X, Y, node2com_flow_all.reshape(ny,nx),
        #                    cmap=src_cmap)
        #     plt.colorbar()
        #     plt.title('%d-time-step probability to community %d of level %d' % (dt, sel_com[k], level))
        #     fig.savefig(res_dir + 'com/nod2com_flow_phase_lev%d%s_com%02d.%s' % (level, postfix, sel_com[k], fig_format), dpi=300, format=fig_format, bbox_inches='tight')

np.savetxt(res_dir + 'density/density_phase' + postfix + '.txt',
           rho_phase, '%e')
np.savetxt(res_dir + 'com/code_phase' + postfix + '.txt', code_phase, '%e')
np.savetxt(res_dir + 'com/ncom_filt' + postfix + '.txt', ncom_filt, '%d')

np.savetxt(res_dir + 'entropy/entropy_stationary' + postfix + '.txt',
           entropy_stationary, '%e')
np.savetxt(res_dir + 'entropy/entropy_rate' + postfix + '.txt',
           entropy_rate, '%e')

# Reduced
np.savetxt(res_dir + 'entropy/intra_entropy' + postfix + '.txt',
           intra_entropy, '%e')
np.savetxt(res_dir + 'entropy/reduced_compression_gap' + postfix + '.txt',
           reduced_compression_gap, '%e')
np.savetxt(res_dir + 'entropy/reduced_entropy_stationary' + postfix + '.txt',
           reduced_entropy_stationary, '%e')
np.savetxt(res_dir + 'entropy/reduced_entropy_rate' + postfix + '.txt',
          reduced_entropy_rate, '%e')

plt.figure()
plt.plot(rng_dt, rho_phase)
plt.title('Edge density')
plt.savefig(res_dir + 'density/rho' + postfix + '.png', format=fig_format)

plt.figure()
plt.plot(rng_dt, ncom_filt)
plt.plot(rng_dt, ncom, '--b')
plt.title('Number of communities')
plt.savefig(res_dir + 'com/ncom' + postfix + '.png', format=fig_format)

plt.figure()
plt.plot(rng_dt, entropy_rate, '-g')
plt.plot(rng_dt, entropy_stationary, '-r')
plt.plot(rng_dt, code_phase, '-b')
plt.plot(rng_dt, reduced_entropy_rate, '--g')
plt.plot(rng_dt, reduced_entropy_stationary, '--r')
plt.plot(rng_dt, intra_entropy, '--y')
plt.plot(rng_dt, reduced_code, '--b')

plt.title('Entropy')
#plt.legend({'Entropy rate', 'Entropy of stationary distribution', 'Code length', 'Reduced entropy rate', 'Reduced entropy stationary'}, loc=8)
plt.savefig(res_dir + 'entropy/entropies' + postfix + '.png',
            format=fig_format)

plt.figure()
plt.plot(rng_dt, reduced_compression_gap)
plt.title('Reduced compression gap')
plt.savefig(res_dir + 'entropy/reduced_compression_gap' + postfix + '.png', format=fig_format)

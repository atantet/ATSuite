#ifndef TRANSFEROPERATORTEST_HPP
#define TRANSFEROPERATORTEST_HPP

#include <vector>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_vector_int.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_matrix_complex.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <Eigen/Dense>
#include <Eigen/Sparse>
#include "atmath.hpp"
#include "transferOperator.hpp"

typedef Eigen::Triplet<double> triplet;
typedef std::vector<triplet> tripletVector;
typedef Eigen::SparseMatrix<double, Eigen::ColMajor> SpMatCSC;
typedef Eigen::SparseMatrix<double, Eigen::RowMajor> SpMatCSR;


// Declarations
SpMatCSR* getTransitionMatrixShuffled(const gsl_vector_int *, const size_t,
				      const size_t);
tripletVector* getTransitionCountTripletsShuffled(const gsl_vector_int *,
						  const size_t);

// Definitions
SpMatCSR* getSurrogateSpectrum(const gsl_vector_int * gridMem,
			       const size_t N,
			       const size_t tauStep,
			       gsl_rng_type *rngType=gsl_rng_ranlxs1,
			       int seed=0)
{
  SpMatCSR *C = new SpMatCSR(N, N);
  tripletVector *T;
  std::vector< std::vector <int > > boxDest;
  std::vector<int> rowTmp;

  // Get transition count triplets
  T = getTransitionCountTriplets(gridMem, tauStep);
  
  // Get transition count matrix
  C->setFromTriplets(T->begin(), T->end());


  // Set random generator and its seed
  gsl_rng *r = gsl_rng_alloc(rngType);
  gsl_rng_set(r, seed);
  
  //

  delete T;
  gsl_rng_free(r);

  return P;
}

void getSurrogateSpectrum(SpMatCSR *C, int nev, gsl_rng *r, int Ns,
			  gsl_matrix_complex *EigValDist)
{
  gsl_vector_int *nTransPerRow;
  SpMatCSR *Ps;
  double *EigValReal;
  double *EigValImag;

  // Allocate
  EigValDist = gsl_matrix_complex_alloc(nev, Ns);
  
  // Get row sums
  nTransPerRow = getRowSum(C);

  // Get Ns surrogate spectra
  for (int s = 0; s < Ns; s++){
    // Get shuffled count matrix
    Ps = getShuffledCountMatrix(C, nTransPerRow, r);
    // Get transition matrix
    toStochastic(Ps);
    // Get eigenvalues
    getEig(Ps, EigValReal, EigValImag);
    // Store
    for (int ev = 0; ev < nev; ev++)
      gsl_matrix_complex_set(EigValDist, ev, s,
			     std::complex<double>(EigValReal[ev],
						  EigValImag[ev]));
    // Clean
    delete[] EigValReal;
    delete[] EigValImag;
    delete Ps;
  }

  gsl_vector_free(rowSum);

  return;
}

SpMatCSR *getShuffledCountMatrix(SpMatCSR *C,
				 gsl_vector_int *nTransPerRow,
				 gsl_rng *r)
{
  int N = C->rows();
  SpMatCSR *Cs = new SpMatCSR(N, N);
  tripletVector *Ts = new tripletVector;
  
  // Reserve shuffled transition count triplet
  Ts->reserve(C->nonZeros());

  // Shuffle each row
  for (int i = 0; i < N; i++)
    getShuffledRow(C, i, gsl_vector_int_get(nTransPerRow, i), Ts, r);

  // Get shuffled matrix
  Cs->setFromTriplets(T->begin(), T->end());
  delete Ts;
  
  return Cs;
}

void getShuffledRow(SpMatCSR *C, int iRow, int nTrans,
		    tripletVector *Ts,
		    gsl_rng *r)
{
  int k;
  gsl_vector_int *dstRepeat = gsl_vector_int_alloc(nTrans);
  unsigned long int sampleIdx;
  int sample;

  // Get repeated list of destinations
  k = 0;
  for (SpMatCSR::InnerIterator it(*C, iRow); it; ++it){
    for (int r = 0; r < it.value(); r++){
      gsl_vector_int_set(dstRepeat, k, it.col());
      k++;
    }
  }

  // Shuffle row
  for (k = 0; k < nTrans; k++){
    sampleIdx = gsl_rng_uniform_int(r, nTrans);
    sample = gsl_vector_int_get(dstRepeat, sampleIdx);
    Ts->push_back(triplet(iRow, sample, 1));
  }

  gsl_vector_int_free(dstRepeat);
  return;
}


#endif
